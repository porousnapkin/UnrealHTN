// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "HTNProperty.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "HTNPlan.generated.h"

/**
 * Enum defining the possible statuses of a plan during execution.
 */
UENUM(BlueprintType)
enum class EHTNPlanStatus : uint8
{
 /** Plan has not been started yet */
 NotStarted UMETA(DisplayName = "Not Started"),
    
 /** Plan is currently executing */
 Executing UMETA(DisplayName = "Executing"),
    
 /** Plan execution is paused */
 Paused UMETA(DisplayName = "Paused"),
    
 /** Plan has completed successfully */
 Completed UMETA(DisplayName = "Completed"),
    
 /** Plan has failed during execution */
 Failed UMETA(DisplayName = "Failed"),
    
 /** Plan was aborted before completion */
 Aborted UMETA(DisplayName = "Aborted")
};

/**
 * Structure representing a complete plan generated by the HTN planner.
 * A plan is an ordered sequence of primitive tasks to be executed.
 * This enhanced version includes execution metadata, serialization,
 * and plan manipulation capabilities.
 */
USTRUCT(BlueprintType)
struct HIERARCHICALTASKNETWORKRUNTIME_API FHTNPlan
{
    GENERATED_BODY()

public:
    /** Default constructor */
    FHTNPlan();
    
    /** Constructor with task list and cost */
    FHTNPlan(const TArray<UHTNPrimitiveTask*>& InTasks, float InTotalCost = 0.0f);
    
    /** Copy constructor */
    FHTNPlan(const FHTNPlan& Other);
    
    /** Move constructor */
    FHTNPlan(FHTNPlan&& Other) noexcept;
    
    /** Copy assignment operator */
    FHTNPlan& operator=(const FHTNPlan& Other);
    
    /** Move assignment operator */
    FHTNPlan& operator=(FHTNPlan&& Other) noexcept;
    
    /** Less-than operator for priority queue sorting (lower cost plans come first) */
    bool operator<(const FHTNPlan& Other) const;
    
    /** Equal operator */
    bool operator==(const FHTNPlan& Other) const;
    
    /** Inequality operator */
    bool operator!=(const FHTNPlan& Other) const;

    /** The primitive tasks in this plan, in execution order */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    TArray<UHTNPrimitiveTask*> Tasks;
    
    /** The total cost of this plan (sum of individual task costs) */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    float TotalCost;
    
    /** Index of the currently executing task */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    int32 CurrentTaskIndex;
    
    /** Whether this plan is currently executing */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    uint8 bIsExecuting : 1;
    
    /** Whether this plan has completed execution */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    uint8 bIsComplete : 1;
    
    /** Whether this plan failed during execution */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    uint8 bFailed : 1;
    
    /** Whether the plan is currently paused */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    uint8 bIsPaused : 1;
    
    /** Time when plan execution started */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    float StartTime;
    
    /** Time when plan execution ended (if complete) */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    float EndTime;
    
    /** Current plan execution status */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    EHTNPlanStatus Status;
    
    /** Map of task parameters for parameterized execution */
    UPROPERTY(BlueprintReadWrite, Category = "HTN|Plan|Execution")
    TMap<FName, FHTNProperty> TaskParameters;
    
    /** Map of task results from completed tasks */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan|Execution")
    TMap<FName, FHTNProperty> TaskResults;
    
    /** Dependencies between tasks (key: task index, value: dependent task indices) */
    TMap<int32, TArray<int32>> TaskDependencies;

    /**
     * Gets a string representation of this plan for debugging.
     * 
     * @return A formatted string describing the plan
     */
    FString ToString() const;
    
    /**
     * Clears this plan to an empty state.
     */
    void Clear();
    
    /**
     * Checks if this plan is empty (contains no tasks).
     * 
     * @return True if the plan has no tasks, false otherwise
     */
    bool IsEmpty() const;
    
    /**
     * Gets the number of tasks in this plan.
     * 
     * @return The number of tasks
     */
    int32 GetLength() const;
    
    /**
     * Gets a specific task from the plan.
     * 
     * @param Index - The index of the task to get
     * @return The task at the specified index, or nullptr if index is out of bounds
     */
    UHTNPrimitiveTask* GetTask(int32 Index) const;
    
    /**
     * Gets the current task being executed.
     * 
     * @return The current task, or nullptr if the plan is not executing or is complete
     */
    UHTNPrimitiveTask* GetCurrentTask() const;
    
    /**
     * Adds a task to the end of the plan.
     * 
     * @param Task - The task to add
     */
    void AddTask(UHTNPrimitiveTask* Task);
    
    /**
     * Checks if the plan is valid.
     * A valid plan has at least one task and all tasks are non-null.
     * 
     * @return True if the plan is valid, false otherwise
     */
    bool IsValid() const;
    
    /**
     * Gets the remaining tasks in the plan (those that have not been executed yet).
     * 
     * @return Array of remaining tasks
     */
    TArray<UHTNPrimitiveTask*> GetRemainingTasks() const;
    
    /**
     * Gets the executed tasks in the plan (those that have already been completed).
     * 
     * @return Array of executed tasks
     */
    TArray<UHTNPrimitiveTask*> GetExecutedTasks() const;
    
    /**
     * Merges this plan with another plan.
     * Tasks from the other plan are appended to this plan.
     * 
     * @param OtherPlan - The plan to merge with
     * @return True if the merge was successful
     */
    bool MergeWith(const FHTNPlan& OtherPlan);
    
    /**
     * Extracts a subplan from this plan.
     * 
     * @param StartIndex - The starting task index
     * @param EndIndex - The ending task index (inclusive)
     * @return The extracted subplan
     */
    FHTNPlan ExtractSubplan(int32 StartIndex, int32 EndIndex) const;
    
    /**
     * Replaces a section of this plan with tasks from another plan.
     * 
     * @param StartIndex - The starting task index to replace
     * @param EndIndex - The ending task index to replace (inclusive)
     * @param ReplacementPlan - The plan containing replacement tasks
     * @return True if the replacement was successful
     */
    bool ReplaceSection(int32 StartIndex, int32 EndIndex, const FHTNPlan& ReplacementPlan);
    
    /**
     * Finds tasks in the plan by name.
     * 
     * @param TaskName - The name to search for
     * @return Array of indices where matching tasks were found
     */
    TArray<int32> FindTasksByName(FName TaskName) const;
    
    /**
     * Finds tasks in the plan by class.
     * 
     * @param TaskClass - The class to search for
     * @return Array of indices where matching tasks were found
     */
    TArray<int32> FindTasksByClass(TSubclassOf<UHTNPrimitiveTask> TaskClass) const;
    
    /**
     * Sets a parameter for a specific task.
     * 
     * @param TaskIndex - The index of the task
     * @param ParamName - The name of the parameter
     * @param ParamValue - The value of the parameter
     * @return True if the parameter was set successfully
     */
    bool SetTaskParameter(int32 TaskIndex, FName ParamName, const FHTNProperty& ParamValue);
    
    /**
     * Gets a parameter for a specific task.
     * 
     * @param TaskIndex - The index of the task
     * @param ParamName - The name of the parameter
     * @param OutValue - The value of the parameter
     * @return True if the parameter was found
     */
    bool GetTaskParameter(int32 TaskIndex, FName ParamName, FHTNProperty& OutValue) const;
    
    /**
     * Sets a result for a specific task.
     * 
     * @param TaskIndex - The index of the task
     * @param ResultName - The name of the result
     * @param ResultValue - The value of the result
     * @return True if the result was set successfully
     */
    bool SetTaskResult(int32 TaskIndex, FName ResultName, const FHTNProperty& ResultValue);
    
    /**
     * Gets a result for a specific task.
     * 
     * @param TaskIndex - The index of the task
     * @param ResultName - The name of the result
     * @param OutValue - The value of the result
     * @return True if the result was found
     */
    bool GetTaskResult(int32 TaskIndex, FName ResultName, FHTNProperty& OutValue) const;
    
    /**
     * Adds a dependency between two tasks.
     * 
     * @param TaskIndex - The index of the dependent task
     * @param DependsOnTaskIndex - The index of the task it depends on
     * @return True if the dependency was added successfully
     */
    bool AddTaskDependency(int32 TaskIndex, int32 DependsOnTaskIndex);
    
    /**
     * Checks if a task has dependencies that are not yet satisfied.
     * 
     * @param TaskIndex - The index of the task to check
     * @return True if all dependencies are satisfied
     */
    bool AreTaskDependenciesSatisfied(int32 TaskIndex) const;
    
    /**
     * Serializes the plan to JSON format.
     * 
     * @return A JSON string representing the plan
     */
    FString ToJson() const;
    
    /**
     * Deserializes a plan from JSON format.
     * 
     * @param JsonString - The JSON string to parse
     * @return True if deserialization was successful, false otherwise
     */
    bool FromJson(const FString& JsonString);
    
    /**
     * Serializes the plan to binary format.
     * 
     * @param OutData - The binary data
     * @return True if serialization was successful
     */
    bool ToBinary(TArray<uint8>& OutData);
    
    /**
     * Deserializes a plan from binary format.
     * 
     * @param InData - The binary data
     * @return True if deserialization was successful
     */
    bool FromBinary(const TArray<uint8>& InData);
    
    /**
     * Creates a visual representation of the plan as a graph.
     * 
     * @return A string containing a DOT graph representation
     */
    FString ToGraphViz() const;
    
    /**
     * Creates a step-by-step execution preview.
     * 
     * @return A string containing the execution preview
     */
    FString CreateExecutionPreview() const;
};

/**
 * Blueprint function library for HTN Plan operations.
 * Provides static functions to work with HTN plans from Blueprint.
 */
UCLASS()
class HIERARCHICALTASKNETWORKRUNTIME_API UHTNPlanLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()
    
public:
    /**
     * Clears a plan to an empty state.
     * 
     * @param Plan - The plan to clear
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static void ClearPlan(UPARAM(ref) FHTNPlan& Plan);
    
    /**
     * Checks if a plan is empty (contains no tasks).
     * 
     * @param Plan - The plan to check
     * @return True if the plan has no tasks, false otherwise
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static bool IsEmptyPlan(const FHTNPlan& Plan);
    
    /**
     * Gets the number of tasks in a plan.
     * 
     * @param Plan - The plan to query
     * @return The number of tasks in the plan
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static int32 GetPlanLength(const FHTNPlan& Plan);
    
    /**
     * Gets a specific task from the plan.
     * 
     * @param Plan - The plan to query
     * @param Index - The index of the task to get
     * @return The task at the specified index, or nullptr if index is out of bounds
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static UHTNPrimitiveTask* GetTaskFromPlan(const FHTNPlan& Plan, int32 Index);
    
    /**
     * Gets the current task being executed.
     * 
     * @param Plan - The plan to query
     * @return The current task, or nullptr if the plan is not executing or is complete
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static UHTNPrimitiveTask* GetCurrentTask(const FHTNPlan& Plan);
    
    /**
     * Adds a task to the end of the plan.
     * 
     * @param Plan - The plan to modify
     * @param Task - The task to add
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static void AddTaskToPlan(UPARAM(ref) FHTNPlan& Plan, UHTNPrimitiveTask* Task);
    
    /**
     * Checks if the plan is valid.
     * A valid plan has at least one task and all tasks are non-null.
     * 
     * @param Plan - The plan to check
     * @return True if the plan is valid, false otherwise
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static bool IsValidPlan(const FHTNPlan& Plan);
    
    /**
     * Gets the remaining tasks in the plan (those that have not been executed yet).
     * 
     * @param Plan - The plan to query
     * @return Array of remaining tasks
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static TArray<UHTNPrimitiveTask*> GetRemainingTasks(const FHTNPlan& Plan);
    
    /**
     * Gets the executed tasks in the plan (those that have already been completed).
     * 
     * @param Plan - The plan to query
     * @return Array of executed tasks
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static TArray<UHTNPrimitiveTask*> GetExecutedTasks(const FHTNPlan& Plan);
    
    /**
     * Merges one plan with another plan.
     * Tasks from the other plan are appended to this plan.
     * 
     * @param TargetPlan - The plan to merge into
     * @param SourcePlan - The plan to merge from
     * @return True if the merge was successful
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static bool MergePlans(UPARAM(ref) FHTNPlan& TargetPlan, const FHTNPlan& SourcePlan);
    
    /**
     * Extracts a subplan from a plan.
     * 
     * @param Plan - The plan to extract from
     * @param StartIndex - The starting task index
     * @param EndIndex - The ending task index (inclusive)
     * @return The extracted subplan
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static FHTNPlan ExtractSubplan(const FHTNPlan& Plan, int32 StartIndex, int32 EndIndex);
    
    /**
     * Replaces a section of a plan with tasks from another plan.
     * 
     * @param Plan - The plan to modify
     * @param StartIndex - The starting task index to replace
     * @param EndIndex - The ending task index to replace (inclusive)
     * @param ReplacementPlan - The plan containing replacement tasks
     * @return True if the replacement was successful
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static bool ReplacePlanSection(UPARAM(ref) FHTNPlan& Plan, int32 StartIndex, int32 EndIndex, const FHTNPlan& ReplacementPlan);
    
    /**
     * Finds tasks in the plan by name.
     * 
     * @param Plan - The plan to search in
     * @param TaskName - The name to search for
     * @return Array of indices where matching tasks were found
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static TArray<int32> FindTasksByName(const FHTNPlan& Plan, FName TaskName);
    
    /**
     * Finds tasks in the plan by class.
     * 
     * @param Plan - The plan to search in
     * @param TaskClass - The class to search for
     * @return Array of indices where matching tasks were found
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static TArray<int32> FindTasksByClass(const FHTNPlan& Plan, TSubclassOf<UHTNPrimitiveTask> TaskClass);
    
    /**
     * Sets a parameter for a specific task.
     * 
     * @param Plan - The plan to modify
     * @param TaskIndex - The index of the task
     * @param ParamName - The name of the parameter
     * @param ParamValue - The value of the parameter
     * @return True if the parameter was set successfully
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static bool SetTaskParameter(UPARAM(ref) FHTNPlan& Plan, int32 TaskIndex, FName ParamName, const FHTNProperty& ParamValue);
    
    /**
     * Gets a parameter for a specific task.
     * 
     * @param Plan - The plan to query
     * @param TaskIndex - The index of the task
     * @param ParamName - The name of the parameter
     * @param OutValue - The value of the parameter
     * @return True if the parameter was found
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static bool GetTaskParameter(const FHTNPlan& Plan, int32 TaskIndex, FName ParamName, FHTNProperty& OutValue);
    
    /**
     * Sets a result for a specific task.
     * 
     * @param Plan - The plan to modify
     * @param TaskIndex - The index of the task
     * @param ResultName - The name of the result
     * @param ResultValue - The value of the result
     * @return True if the result was set successfully
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static bool SetTaskResult(UPARAM(ref) FHTNPlan& Plan, int32 TaskIndex, FName ResultName, const FHTNProperty& ResultValue);
    
    /**
     * Gets a result for a specific task.
     * 
     * @param Plan - The plan to query
     * @param TaskIndex - The index of the task
     * @param ResultName - The name of the result
     * @param OutValue - The value of the result
     * @return True if the result was found
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static bool GetTaskResult(const FHTNPlan& Plan, int32 TaskIndex, FName ResultName, FHTNProperty& OutValue);
    
    /**
     * Adds a dependency between two tasks.
     * 
     * @param Plan - The plan to modify
     * @param TaskIndex - The index of the dependent task
     * @param DependsOnTaskIndex - The index of the task it depends on
     * @return True if the dependency was added successfully
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan")
    static bool AddTaskDependency(UPARAM(ref) FHTNPlan& Plan, int32 TaskIndex, int32 DependsOnTaskIndex);
    
    /**
     * Checks if a task has dependencies that are not yet satisfied.
     * 
     * @param Plan - The plan to query
     * @param TaskIndex - The index of the task to check
     * @return True if all dependencies are satisfied
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static bool AreTaskDependenciesSatisfied(const FHTNPlan& Plan, int32 TaskIndex);
    
    /**
     * Generates a string representation of the plan in GraphViz DOT format.
     * This can be used to visualize the plan structure.
     * 
     * @param Plan - The plan to visualize
     * @return A string containing the GraphViz representation
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan|Visualization")
    static FString GenerateGraphViz(const FHTNPlan& Plan);
    
    /**
     * Creates a detailed step-by-step execution preview of the plan.
     * 
     * @param Plan - The plan to preview
     * @return A string containing the execution preview
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan|Visualization")
    static FString CreateExecutionPreview(const FHTNPlan& Plan);
    
    /**
     * Converts a plan to a JSON string for serialization.
     * 
     * @param Plan - The plan to serialize
     * @return A JSON string representing the plan
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan|Serialization")
    static FString PlanToJson(const FHTNPlan& Plan);
    
    /**
     * Attempts to reconstruct a plan from a JSON string.
     * Note: This has limitations regarding task reconstruction.
     * 
     * @param JsonString - The JSON string to parse
     * @param OutPlan - The resulting plan
     * @return True if deserialization was successful
     */
    UFUNCTION(BlueprintCallable, Category = "HTN|Plan|Serialization")
    static bool PlanFromJson(const FString& JsonString, UPARAM(ref) FHTNPlan& OutPlan);
    
    /**
     * Gets a string representation of the plan for debugging.
     * 
     * @param Plan - The plan to convert to string
     * @return A formatted string describing the plan
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static FString PlanToString(const FHTNPlan& Plan);
    
    /**
     * Gets the current status of a plan as a string.
     * 
     * @param Plan - The plan to query
     * @return String representation of the plan status
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static FString GetPlanStatusString(const FHTNPlan& Plan);
    
    /**
     * Gets the total cost of a plan.
     * 
     * @param Plan - The plan to query
     * @return The total cost of the plan
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static float GetPlanTotalCost(const FHTNPlan& Plan);
    
    /**
     * Checks if a plan is currently executing.
     * 
     * @param Plan - The plan to check
     * @return True if the plan is executing, false otherwise
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static bool IsPlanExecuting(const FHTNPlan& Plan);
    
    /**
     * Checks if a plan is complete.
     * 
     * @param Plan - The plan to check
     * @return True if the plan is complete, false otherwise
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static bool IsPlanComplete(const FHTNPlan& Plan);
    
    /**
     * Checks if a plan has failed.
     * 
     * @param Plan - The plan to check
     * @return True if the plan has failed, false otherwise
     */
    UFUNCTION(BlueprintPure, Category = "HTN|Plan")
    static bool HasPlanFailed(const FHTNPlan& Plan);
};