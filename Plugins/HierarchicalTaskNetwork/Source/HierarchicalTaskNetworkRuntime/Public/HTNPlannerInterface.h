// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "HTNTask.h"
#include "HTNPrimitiveTask.h"
#include "HTNPlannerInterface.generated.h"

/**
 * Enum defining the possible reasons a planning operation might fail
 */
UENUM(BlueprintType)
enum class EHTNPlannerFailReason : uint8
{
    /** No failure, planning was successful */
    None UMETA(DisplayName = "None"),
    
    /** No applicable methods were found for a compound task */
    NoApplicableMethods UMETA(DisplayName = "No Applicable Methods"),
    
    /** A primitive task's preconditions were not satisfied */
    PreconditionFailed UMETA(DisplayName = "Precondition Failed"),
    
    /** Maximum planning depth was reached */
    MaxDepthReached UMETA(DisplayName = "Max Depth Reached"),
    
    /** Planning operation timed out */
    Timeout UMETA(DisplayName = "Timeout"),
    
    /** Maximum number of plans to consider was reached */
    MaxPlansReached UMETA(DisplayName = "Max Plans Reached"),
    
    /** No valid plan could be found */
    NoValidPlan UMETA(DisplayName = "No Valid Plan"),
    
    /** An unexpected error occurred during planning */
    UnexpectedError UMETA(DisplayName = "Unexpected Error")
};

/**
 * Structure representing a complete plan generated by the HTN planner.
 * A plan is an ordered sequence of primitive tasks to be executed.
 */
USTRUCT(BlueprintType)
struct HIERARCHICALTASKNETWORKRUNTIME_API FHTNPlan
{
    GENERATED_BODY()

public:
    /** Default constructor */
    FHTNPlan();
    
    /** Constructor with task list and cost */
    FHTNPlan(const TArray<UHTNPrimitiveTask*>& InTasks, float InTotalCost = 0.0f);
    
    /** Copy constructor */
    FHTNPlan(const FHTNPlan& Other);
    
    /** Move constructor */
    FHTNPlan(FHTNPlan&& Other) noexcept;
    
    /** Copy assignment operator */
    FHTNPlan& operator=(const FHTNPlan& Other);
    
    /** Move assignment operator */
    FHTNPlan& operator=(FHTNPlan&& Other) noexcept;
    
    /** Less-than operator for priority queue sorting (lower cost plans come first) */
    bool operator<(const FHTNPlan& Other) const;
    
    /** Equal operator */
    bool operator==(const FHTNPlan& Other) const;
    
    /** Inequality operator */
    bool operator!=(const FHTNPlan& Other) const;

    /** The primitive tasks in this plan, in execution order */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    TArray<UHTNPrimitiveTask*> Tasks;
    
    /** The total cost of this plan (sum of individual task costs) */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    float TotalCost;
    
    /** Index of the currently executing task */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    int32 CurrentTaskIndex;
    
    /** Whether this plan is currently executing */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    uint8 bIsExecuting : 1;
    
    /** Whether this plan has completed execution */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    uint8 bIsComplete : 1;
    
    /** Whether this plan failed during execution */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    uint8 bFailed : 1;
    
    /** Time when plan execution started */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    float StartTime;
    
    /** Time when plan execution ended (if complete) */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Plan")
    float EndTime;

    /**
     * Gets a string representation of this plan for debugging.
     * 
     * @return A formatted string describing the plan
     */
    FString ToString() const;
    
    /**
     * Clears this plan to an empty state.
     */
    void Clear();
    
    /**
     * Checks if this plan is empty (contains no tasks).
     * 
     * @return True if the plan has no tasks, false otherwise
     */
    bool IsEmpty() const;
    
    /**
     * Gets the number of tasks in this plan.
     * 
     * @return The number of tasks
     */
    int32 GetLength() const;
    
    /**
     * Gets a specific task from the plan.
     * 
     * @param Index - The index of the task to get
     * @return The task at the specified index, or nullptr if index is out of bounds
     */
    UHTNPrimitiveTask* GetTask(int32 Index) const;
    
    /**
     * Gets the current task being executed.
     * 
     * @return The current task, or nullptr if the plan is not executing or is complete
     */
    UHTNPrimitiveTask* GetCurrentTask() const;
    
    /**
     * Adds a task to the end of the plan.
     * 
     * @param Task - The task to add
     */
    void AddTask(UHTNPrimitiveTask* Task);
    
    /**
     * Checks if the plan is valid.
     * A valid plan has at least one task and all tasks are non-null.
     * 
     * @return True if the plan is valid, false otherwise
     */
    bool IsValid() const;
    
    /**
     * Serializes the plan to JSON format.
     * 
     * @return A JSON string representing the plan
     */
    FString ToJson() const;
    
    /**
     * Deserializes a plan from JSON format.
     * 
     * @param JsonString - The JSON string to parse
     * @return True if deserialization was successful, false otherwise
     */
    bool FromJson(const FString& JsonString);
};

/**
 * Structure containing the results of a planning operation.
 */
USTRUCT(BlueprintType)
struct HIERARCHICALTASKNETWORKRUNTIME_API FHTNPlannerResult
{
    GENERATED_BODY()

public:
    /** Default constructor */
    FHTNPlannerResult();
    
    /** The generated plan (only valid if bSuccess is true) */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Planner")
    FHTNPlan Plan;
    
    /** Whether the planning operation was successful */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Planner")
    uint8 bSuccess : 1;
    
    /** The reason for planning failure (only valid if bSuccess is false) */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Planner")
    EHTNPlannerFailReason FailReason;
    
    /** How many nodes were explored during planning */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Planner|Metrics")
    int32 NodesExplored;
    
    /** How many plans were generated and evaluated */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Planner|Metrics")
    int32 PlansGenerated;
    
    /** Maximum depth reached during planning */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Planner|Metrics")
    int32 MaxDepthReached;
    
    /** Time spent planning (in seconds) */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Planner|Metrics")
    float PlanningTime;
    
    /** Detailed information about the planning process for debugging */
    UPROPERTY(BlueprintReadOnly, Category = "HTN|Planner|Debug")
    FString DebugInfo;
    
    /**
     * Gets a string representation of the planning result for debugging.
     * 
     * @return A formatted string describing the planning result
     */
    FString ToString() const;
};

/**
 * Structure containing configuration parameters for planning operations.
 */
USTRUCT(BlueprintType)
struct HIERARCHICALTASKNETWORKRUNTIME_API FHTNPlanningConfig
{
    GENERATED_BODY()

public:
    /** Default constructor with reasonable defaults */
    FHTNPlanningConfig();
    
    /** Maximum depth for the planning search (to prevent infinite recursion) */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HTN|Planner|Config", meta = (ClampMin = "1", ClampMax = "100"))
    int32 MaxSearchDepth;
    
    /** Maximum time allowed for planning (in seconds, 0 = no limit) */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HTN|Planner|Config", meta = (ClampMin = "0.0"))
    float PlanningTimeout;
    
    /** Maximum number of plans to consider before selecting the best one (0 = no limit) */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HTN|Planner|Config", meta = (ClampMin = "0"))
    int32 MaxPlansToConsider;
    
    /** Whether to use heuristic optimizations during planning */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HTN|Planner|Config")
    uint8 bUseHeuristics : 1;
    
    /** Weight for the heuristic function (0.0 = ignore heuristics, 1.0 = fully rely on heuristics) */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HTN|Planner|Config", meta = (ClampMin = "0.0", ClampMax = "1.0", EditCondition = "bUseHeuristics"))
    float HeuristicWeight;
    
    /** Whether to cache partial decompositions for reuse */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HTN|Planner|Config")
    uint8 bCacheDecompositions : 1;
    
    /** Whether to enable detailed debugging output */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HTN|Planner|Config")
    uint8 bDetailedDebugging : 1;
};

/**
 * Interface for HTN planners.
 * Defines the methods that all HTN planner implementations must provide.
 */
UINTERFACE(MinimalAPI, Blueprintable)
class UHTNPlannerInterface : public UInterface
{
    GENERATED_BODY()
};

class HIERARCHICALTASKNETWORKRUNTIME_API IHTNPlannerInterface
{
    GENERATED_BODY()

public:
    /**
     * Generate a plan to achieve the specified goal tasks from the given world state.
     * 
     * @param WorldState - The initial world state
     * @param GoalTasks - The tasks to achieve (typically compound tasks that will be decomposed)
     * @param Config - Configuration parameters for the planning process
     * @return The result of the planning operation
     */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "HTN|Planner")
    FHTNPlannerResult GeneratePlan(
        const UHTNWorldState* WorldState,
        const TArray<UHTNTask*>& GoalTasks,
        const FHTNPlanningConfig& Config);
    
    /**
     * Validate if a plan is still valid given the current world state.
     * 
     * @param Plan - The plan to validate
     * @param WorldState - The current world state
     * @return True if the plan is still valid, false otherwise
     */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "HTN|Planner")
    bool ValidatePlan(
        const FHTNPlan& Plan,
        const UHTNWorldState* WorldState);
    
    /**
     * Generate a partial plan that extends an existing plan.
     * Useful for incremental planning during execution.
     * 
     * @param ExistingPlan - The existing plan to extend
     * @param WorldState - The current world state
     * @param GoalTasks - The tasks to achieve
     * @param Config - Configuration parameters for the planning process
     * @return The result of the planning operation
     */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "HTN|Planner")
    FHTNPlannerResult GeneratePartialPlan(
        const FHTNPlan& ExistingPlan,
        const UHTNWorldState* WorldState,
        const TArray<UHTNTask*>& GoalTasks,
        const FHTNPlanningConfig& Config);
    
    /**
     * Configure the planner with the provided parameters.
     * This allows changing the planning behavior without creating a new planner.
     * 
     * @param NewConfig - The new configuration parameters
     */
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "HTN|Planner")
    void ConfigurePlanner(const FHTNPlanningConfig& NewConfig);
};